import * as _shared_core from './core';
import { ClientParams as ClientParams$1, WithIdempotencyKey, Pagination, FeeConfiguration } from './core';
import * as _shared_clients_user_controlled_wallets from './clients/user-controlled-wallets';
import { GenerateUserTokenResponse, Blockchain, MetadataField, ListUserChallengesStatusEnum, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, ListTransactionsOperationEnum, ListTransactionsStateEnum, ListTransactionsTxTypeEnum, GetTransactionTxTypeEnum } from './clients/user-controlled-wallets';

/**
 * Represents input parameters for identifying a user using a JWT token.
 */
interface UserTokenInput {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    userId?: never;
}
/**
 * Represents input parameters for identifying a user using their system-generated unique identifier.
 */
interface UserIdInput {
    userToken?: never;
    /**
     * Unique system-generated identifier for the user.
     */
    userId: string;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type UserIdOrTokenInput = UserIdInput | UserTokenInput;
/**
 * Represents a user token that is cached along with its expiration time.
 */
type CachedUserToken = GenerateUserTokenResponse & {
    /**
     * The expiration time in seconds for the cached user token.
     */
    expirationTime: number;
};
type ClientParams = ClientParams$1<Record<string, CachedUserToken>>;

/**
 * Represents the input for creating a challenge for PIN setup and create wallet(s).
 */
type CreateUserPinWithWalletsInput = {
    /**
     * Blockchain(s) the requested wallets will be created on.
     */
    blockchains: Blockchain[];
    /**
     * List of metadata fields to associate with the corresponding wallet.
     */
    metadata?: MetadataField[];
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents input parameters for managing a user's PIN.
 */
type ManageUserPinInput = UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input parameters for fetching a user's challenges.
 */
type ListUserChallengesInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    /**
     * The status of challenges to query. (Optional).
     */
    challengeStatus?: ListUserChallengesStatusEnum;
};

/**
 * Represents the input parameters for fetching a challenge.
 */
type GetUserChallengeInput = {
    /**
     * The unique identifier for the challenge.
     */
    challengeId: string;
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};

/**
 * Represents the input parameters for creating a user token.
 */
type CreateUserTokenInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for listing users.
 */
type ListUsersInput = {
    /**
     * The pin status to filter users. (Optional).
     */
    pinStatus?: ListUsersPinStatusEnum;
    /**
     * The security question status to filter users. (Optional).
     */
    securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum;
} & Pagination;

/**
 * Represents the input parameters for fetching a user by user token.
 */
type GetUserByTokenInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};

/**
 * Represents the input parameters for fetching a user.
 */
type GetUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for creating a user.
 */
type CreateUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};

/**
 * Represents the input parameters for retrieving the NFT balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the NFTs for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: string;
} & UserIdOrTokenInput & Pagination;

/**
 * Represents the input parameters for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: string;
} & UserIdOrTokenInput & Pagination;

/**
 * Represents the input parameters for updating a wallet.
 */
type UpdateWalletInput = {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput;

/**
 * Represents the input parameters for retrieving a wallet.
 */
type GetWalletInput = {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
} & UserIdOrTokenInput;

/**
 * Represents the input for listing wallets.
 */
type ListWalletsFilterInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
} & Partial<UserIdOrTokenInput> & Pagination;

/**
 * Represents the input parameters for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain[];
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: MetadataField[];
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines whether the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: ListTransactionsOperationEnum;
    /**
     * Filters transactions based on their current state.
     */
    state?: ListTransactionsStateEnum;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: ListTransactionsTxTypeEnum;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
    /**
     * Filters transactions based on a userId.
     */
    userId: string;
} & Pagination;

/**
 * Represents the input for retrieving a transaction.
 */
type GetTransactionInput = {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: GetTransactionTxTypeEnum;
} & UserIdOrTokenInput;

/**
 * Represents the input for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction that should be cancelled.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Defines the parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the token to be transferred.
     */
    tokenId: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction that should be accelerated.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;

/**
 * Represents the input to sign the EIP-712 typed structured data from a specified user-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;

/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;

declare const defaultBaseUrl = "https://api.circle.com";
/**
 *
 */
declare function initiateUserControlledWalletsClient({ apiKey, baseUrl, storage }: ClientParams, userAgent?: string): {
    /**
     * Fetches details of a specific token given its unique identifier.
     * Every token in your network of wallets has a UUID associated with it,
     * regardless of whether it's already recognized or was added as a monitored token.
     * @example
     * ```
     * const response = await client.getToken(id);
     * console.log(response.data.token)
     * ```
     */
    getToken: ({ id }: _shared_core.GetTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetTokenId200Response>>;
    /**
     * Generates a challenge for signing the EIP-191 message from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signMessage({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  encodedByHex: false,
     *  message: 'I agree with this transfer',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signMessage: ({ userToken, userId, ...input }: SignMessageInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignUserMessage200Response>>;
    /**
     * Generates a challenge for signing the EIP-712 typed structured data from a specified user-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the account types guide, and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signTypedData({
     *  userToken: 'dummy-user-token',
     *  walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *  data: '{ \"types\": { \"Data\": [{ \"name\": \"dummy\", \"type\": \"string\" }],}, \"domain\": { \"name\": \"Test\", \"chainId\": 1337 }, \"primaryType\": \"Data\", \"message\": { \"dummy\": \"dummy\" }}',
     *  memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     */
    signTypedData: ({ userToken, userId, ...input }: SignTypedDataInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignUserTypedData200Response>>;
    accelerateTransaction: ({ userToken, userId, id, idempotencyKey, }: AccelerateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionAccelerateChallenge200Response>>;
    createTransaction: ({ userToken, userId, idempotencyKey, fee, ...input }: CreateTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionTransferChallenge200Response>>;
    cancelTransaction: ({ userToken, userId, id, idempotencyKey, }: CancelTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserTransactionCancelChallenge200Response>>;
    getTransaction: ({ id, userToken, userId, txType }: GetTransactionInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetTransaction200Response>>;
    listTransactions: ({ userToken, blockchain, destinationAddress, includeAll, operation, state, txHash, txType, userId, walletIds, from, pageAfter, pageBefore, pageSize, to, }: ListTransactionsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListTransactions200Response>>;
    estimateContractExecutionFee: ({ source, abiParameters, ...input }: _shared_core.EstimateContractExecutionFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferEstimateFee200Response>>;
    estimateTransferFee: ({ amount, ...input }: _shared_core.EstimateTransferFeeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferEstimateFee200Response>>;
    validateAddress: (input: _shared_core.ValidateAddressInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateValidateAddress200Response>>;
    createWallet: ({ userToken, userId, idempotencyKey, ...input }: CreateWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWallet200Response>>;
    listWallets: ({ userId, userToken, address, blockchain, from, pageAfter, pageBefore, pageSize, to, walletSetId, refId, }: ListWalletsFilterInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWallets200Response>>;
    getWallet: ({ id, userToken, userId }: GetWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetWallet200Response>>;
    updateWallet: ({ id, name, refId, userToken, userId }: UpdateWalletInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UpdateWallet200Response>>;
    getWalletTokenBalance: ({ walletId, userToken, userId, includeAll, from, name, pageAfter, pageBefore, pageSize, to, tokenAddresses, standard, }: GetWalletTokenBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWalletBallance200Response>>;
    getWalletNFTBalance: ({ walletId, userToken, userId, includeAll, from, name, pageAfter, pageBefore, pageSize, to, tokenAddresses, standard, }: GetWalletNFTBalanceInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListWalletNfts200Response>>;
    createUser: ({ ...input }: CreateUserInput) => Promise<_shared_core.TrimDataResponse<object>>;
    getUser: ({ userId }: GetUserInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUser200Response>>;
    getUserStatus: ({ userToken }: GetUserByTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserByToken200Response>>;
    listUsers: (input?: ListUsersInput | undefined) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListUsers200Response>>;
    createUserToken: ({ ...input }: CreateUserTokenInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserToken200Response>>;
    getUserChallenge: ({ userToken, challengeId }: GetUserChallengeInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserChallenge200Response>>;
    listUserChallenges: ({ userToken, challengeStatus }: ListUserChallengesInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ListUserChallenges200Response>>;
    createUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWithPinChallenge200Response>>;
    createUserPinWithWallets: ({ userToken, userId, idempotencyKey, ...input }: CreateUserPinWithWalletsInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserWithPinChallenge200Response>>;
    updateUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UpdateUserPinChallenge200Response>>;
    restoreUserPin: ({ userToken, userId, idempotencyKey }: ManageUserPinInput) => Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateUserPinRestoreChallenge200Response>>;
};

export { defaultBaseUrl, initiateUserControlledWalletsClient };
