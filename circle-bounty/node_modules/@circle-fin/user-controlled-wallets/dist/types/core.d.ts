import { AxiosResponse } from 'axios';
import * as _shared_clients_configurations from '@shared/clients/configurations';
import { ConfigurationsClient } from '@shared/clients/configurations';
import * as _shared_clients_developer_controlled_wallets from '@shared/clients/developer-controlled-wallets';
import { DeveloperControlledWalletsClient, FeeLevel, TransactionType, Blockchain, Operation, ListTransactionsStateEnum } from '@shared/clients/developer-controlled-wallets';
import { SmartContractPlatformClient } from '@shared/clients/smart-contract-platform';
import { UserControlledWalletsClient, FeeLevel as FeeLevel$1 } from '@shared/clients/user-controlled-wallets';
import { Storage as Storage$1, TrimDataResponse as TrimDataResponse$1 } from '@shared/core';

type TrimDataResponse<T extends {
    data?: unknown;
}> = Omit<AxiosResponse<T>, 'data'> & {
    data?: T['data'];
};
/**
 * Utility function to sanitize the Axios response object by:
 * - removing the redundant 'data' property when calling the 'data' property again on the Axios response
 * - casting the headers to `Record<string, string>` for better type assertion.
 * @param response - The Axios response object.
 * @returns - The sanitized response object.
 */
declare const trimData: <T extends {
    data?: unknown;
}>(response: AxiosResponse<T, any>) => TrimDataResponse<T>;

/**
 * Represents pagination options for querying items.
 */
interface Pagination {
    /**
     * Start time of the query, inclusive.
     */
    from?: string;
    /**
     * End time of the query, inclusive. Defaults to the current time.
     */
    to?: string;
    /**
     * Used to return items before the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageAfter`.
     */
    pageBefore?: string;
    /**
     * Used to return items after the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageBefore`.
     */
    pageAfter?: string;
    /**
     * The number of items to return.
     */
    pageSize?: number;
}
interface APIParams<TClient = DeveloperControlledWalletsClient | UserControlledWalletsClient | SmartContractPlatformClient, TStoredData extends object = object> {
    /**
     * Storage solution for persisting data.
     */
    storage: Storage$1<TStoredData>;
    /**
     * An instance of the Main Client. Ready to be used.
     */
    client: TClient;
    /**
     * An instance of the ConfigurationsClient. Ready to be used.
     */
    configurationsClient: ConfigurationsClient;
}
interface ClientParams<TStoredData extends object = object> {
    /**
     * Api Key that is used to authenticate against Circle APIs.
     */
    apiKey: string;
    /**
     * Optional base URL to override the default: `https://api.circle.com`.
     */
    baseUrl?: string;
    /**
     * Optional custom storage solution for persisting data. We will fallback to InMemoryStorage if none was provided.
     */
    storage?: Storage$1<TStoredData>;
}
type APIReturnType<T extends {
    data?: unknown;
}> = Promise<TrimDataResponse$1<T>>;
/**
 * Represents the configuration for setting fees.
 * It can be either FeeLevelInput, GasInput, or FeeInput.
 */
type FeeConfiguration = {
    /**
     * Use absolute numbers to determine the fees that should be paid.
     */
    type: 'absolute';
    config: {
        /**
         * The maximum price per gas unit (see gasLimit), in gwei.
         * Requires baseFee, priorityFee, and gasLimit, but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods to get this fee's estimates.
         */
        maxFee: string;
        /**
         * The "tip", in gwei, added to the baseFee to incentivize validators.
         * Requires baseFee, maxFee, and gasLimit but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods for fee estimates.
         */
        priorityFee: string;
        /**
         * The maximum gas units for the transaction, required if feeLevel isn't provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
    };
} | {
    /**
     * Use gasLimit and gasPrice for fee determination.
     */
    type: 'gas';
    config: {
        /**
         * The maximum gas units for the transaction, required if feeLevel is not provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
        /**
         * For EIP-1559 supported blockchains, it's the max gas price per gas unit (see gasLimit), in gwei.
         * Requires gasLimit and incompatible with feeLevel, baseFee, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee estimates.
         */
        gasPrice: string;
    };
} | {
    /**
     * Use the fee level to configure the fees that will be paid.
     */
    type: 'level';
    config: {
        /**
         * A dynamic fee level setting (LOW, MEDIUM, HIGH) determining the gas price for the transaction,
         * based on network conditions. Incompatible with gasLimit, gasPrice, baseFee, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee level estimates.
         */
        feeLevel: FeeLevel | FeeLevel$1;
    };
};

declare const getPublicKey: ({ configurationsClient }: APIParams) => () => Promise<TrimDataResponse<_shared_clients_configurations.GetPublicKey200Response>>;

/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}
/**
 * Fetches details of a specific token given its unique identifier.
 * Every token in your network of wallets has a UUID associated with it,
 * regardless of whether it's already recognized or was added as a monitored token.
 * @example
 * ```
 * const response = await client.getToken(id);
 * console.log(response.data.token)
 * ```
 */
declare const getToken: ({ client, }: APIParams<DeveloperControlledWalletsClient | UserControlledWalletsClient>) => ({ id }: GetTokenInput) => Promise<TrimDataResponse<_shared_clients_developer_controlled_wallets.GetTokenId200Response>>;

/**
 * Represents the input for retrieving a transaction.
 */
interface GetTransactionInput {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: TransactionType;
}
/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines if the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: Operation;
    /**
     * Filters transactions based on their current state.
     */
    state?: ListTransactionsStateEnum;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: TransactionType;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & Pagination;

/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<string | number | boolean>;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: Blockchain;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
};
declare const estimateContractExecutionFee: (params: APIParams<DeveloperControlledWalletsClient | UserControlledWalletsClient>) => ({ source, abiParameters, ...input }: EstimateContractExecutionFeeInput) => Promise<TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateTransferEstimateFee200Response>>;

/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the token to be transferred.
     */
    tokenId: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
};
declare const estimateTransferFee: (params: APIParams<DeveloperControlledWalletsClient | UserControlledWalletsClient>) => ({ amount, ...input }: EstimateTransferFeeInput) => Promise<TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateTransferEstimateFee200Response>>;

/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain;
}
declare const validateAddress: ({ client, }: APIParams<DeveloperControlledWalletsClient | UserControlledWalletsClient>) => (input: ValidateAddressInput) => Promise<TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateValidateAddress200Response>>;

interface Storage<TStoredData extends object = object> {
    /**
     * Retrieves the value associated with a given key from the storage.
     * @param key - The key of the value to retrieve.
     * @returns A promise that resolves to the corresponding value, or undefined if not found.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets a value associated with a given key in the storage.
     * @param key - The key of the value to set.
     * @param value - The value to store.
     * @returns A promise that resolves when the operation is complete.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}

/**
 * Represents an in-memory storage implementation.
 */
declare class InMemoryStorage<TStoredData extends object> implements Storage<TStoredData> {
    private data;
    /**
     * Retrieves the value associated with the given key.
     * @param key - The key of the value to retrieve.
     * @returns A Promise that resolves to the value associated with the key, or undefined if the key doesn't exist.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets the value associated with the given key.
     * @param key - The key of the value to set.
     * @param value - The value to associate with the key. Use undefined to remove the key from the storage.
     * @returns A Promise that resolves once the value is set.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}

interface WithIdempotencyKey {
    /**
     * The optional idempotency key.
     * An idempotency key is a unique identifier used to identify and handle duplicate requests
     * in order to ensure idempotent behavior, where multiple identical requests have the same effect as a single request.
     *
     * We will generate one if you do not provide it.
     */
    idempotencyKey?: string;
}
type Cache = {
    /**
     * Public key of the entity.
     */
    publicKey: string;
};
type APIParamsWithEntitySecret<TStoredData extends Cache = Cache> = APIParams<DeveloperControlledWalletsClient | SmartContractPlatformClient, TStoredData> & {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
};

/**
 * Method for securely encrypting an entity secret with a public key.
 * If the public key is not already stored, it fetches and stores it for future use.
 * @param params - Contains the entity secret and methods for managing storage.
 * @returns The encrypted entity secret, returned as a cipher text.
 */
declare const generateEntitySecretCiphertext: (params: APIParamsWithEntitySecret) => Promise<string>;

/**
 * Generates a unique idempotency key using the crypto library.
 * @returns A randomly generated idempotency key in UUID format.
 */
declare const generateIdempotencyKey: () => `${string}-${string}-${string}-${string}-${string}`;

export { type APIParams, type APIReturnType, type ClientParams, type EstimateContractExecutionFeeInput, type EstimateTransferFeeInput, type FeeConfiguration, type GetTokenInput, type GetTransactionInput, InMemoryStorage, type ListTransactionsInput, type Pagination, type Storage, type TrimDataResponse, type ValidateAddressInput, type WithIdempotencyKey, estimateContractExecutionFee, estimateTransferFee, generateEntitySecretCiphertext, generateIdempotencyKey, getPublicKey, getToken, trimData, validateAddress };
